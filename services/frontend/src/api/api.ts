// This client was generated by Platformatic from an OpenAPI specification.

import type { Api } from './api-types'
import type * as Types from './api-types'

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}

function sanitizeUrl(url: string) : string {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
export const setBaseUrl = (newUrl: string) : void => { baseUrl = sanitizeUrl(newUrl) }

export const setDefaultHeaders = (headers: Object): void => { defaultHeaders = headers }

type JSON = Record<string, unknown>
/* @ts-ignore */
function headersToJSON(headers: Headers): JSON {
  const output: JSON = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

const _getMovies = async (url: string, request: Types.GetMoviesRequest): Promise<Types.GetMoviesResponses> => {
  const queryParameters: (keyof Types.GetMoviesRequest)[]  = ['limit', 'offset', 'totalCount', 'fields', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or', 'orderby.id', 'orderby.title']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        (request[qp] as string[]).forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/movies/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

export const getMovies: Api['getMovies'] = async (request: Types.GetMoviesRequest): Promise<Types.GetMoviesResponses> => {
  return await _getMovies(baseUrl, request)
}
const _createMovie = async (url: string, request: Types.CreateMovieRequest): Promise<Types.CreateMovieResponses> => {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/movies/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

export const createMovie: Api['createMovie'] = async (request: Types.CreateMovieRequest): Promise<Types.CreateMovieResponses> => {
  return await _createMovie(baseUrl, request)
}
const _updateMovies = async (url: string, request: Types.UpdateMoviesRequest): Promise<Types.UpdateMoviesResponses> => {
  const queryParameters: (keyof Types.UpdateMoviesRequest)[]  = ['fields', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        (request[qp] as string[]).forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/movies/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

export const updateMovies: Api['updateMovies'] = async (request: Types.UpdateMoviesRequest): Promise<Types.UpdateMoviesResponses> => {
  return await _updateMovies(baseUrl, request)
}
const _getMovieById = async (url: string, request: Types.GetMovieByIdRequest): Promise<Types.GetMovieByIdResponses> => {
  const queryParameters: (keyof Types.GetMovieByIdRequest)[]  = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        (request[qp] as string[]).forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/movies/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

export const getMovieById: Api['getMovieById'] = async (request: Types.GetMovieByIdRequest): Promise<Types.GetMovieByIdResponses> => {
  return await _getMovieById(baseUrl, request)
}
const _updateMovie = async (url: string, request: Types.UpdateMovieRequest): Promise<Types.UpdateMovieResponses> => {
  const queryParameters: (keyof Types.UpdateMovieRequest)[]  = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        (request[qp] as string[]).forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/movies/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

export const updateMovie: Api['updateMovie'] = async (request: Types.UpdateMovieRequest): Promise<Types.UpdateMovieResponses> => {
  return await _updateMovie(baseUrl, request)
}
const _deleteMovies = async (url: string, request: Types.DeleteMoviesRequest): Promise<Types.DeleteMoviesResponses> => {
  const queryParameters: (keyof Types.DeleteMoviesRequest)[]  = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        (request[qp] as string[]).forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/movies/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

export const deleteMovies: Api['deleteMovies'] = async (request: Types.DeleteMoviesRequest): Promise<Types.DeleteMoviesResponses> => {
  return await _deleteMovies(baseUrl, request)
}
const _getExample = async (url: string, request: Types.GetExampleRequest): Promise<Types.GetExampleResponses> => {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/example`, {
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json() as any
    }
  }
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response.text() as any
  }
}

export const getExample: Api['getExample'] = async (request: Types.GetExampleRequest): Promise<Types.GetExampleResponses> => {
  return await _getExample(baseUrl, request)
}
type BuildOptions = {
  headers?: Object
}
export default function build (url: string, options?: BuildOptions) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    getMovies: _getMovies.bind(url, ...arguments),
    createMovie: _createMovie.bind(url, ...arguments),
    updateMovies: _updateMovies.bind(url, ...arguments),
    getMovieById: _getMovieById.bind(url, ...arguments),
    updateMovie: _updateMovie.bind(url, ...arguments),
    deleteMovies: _deleteMovies.bind(url, ...arguments),
    getExample: _getExample.bind(url, ...arguments)
  }
}